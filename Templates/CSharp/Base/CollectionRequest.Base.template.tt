<# // Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.  See License in the project root for license information. #>
<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ include file="Request.Base.template.tt"#>


<#+

// using System.Linq.Enumerable;

// -------------------------------------------------------------
// Methods for standard entity collection classes
// -------------------------------------------------------------
public string GetCollectionClassDefinition(OdcmProperty odcmProperty)
{
    return this.GetClassDefinition(this.GetPropertyCollectionRequestName(odcmProperty));
}

public string GetCollectionRequestConstructor(OdcmProperty odcmProperty)
{
    return this.GetConstructor(this.GetPropertyCollectionRequestName(odcmProperty));
}


// -------------------------------------------------------------
// Methods for the reference of an entity collection
// -------------------------------------------------------------
public string GetCollectionReferencesClassDefinition(OdcmProperty odcmProperty)
{
    return this.GetClassDefinition(this.GetPropertyCollectionReferencesRequestName(odcmProperty));
}

public string GetCollectionReferencesRequestConstructor(OdcmProperty odcmProperty)
{
    return this.GetConstructor(this.GetPropertyCollectionReferencesRequestName(odcmProperty));
}


// -------------------------------------------------------------
// Methods for entity collection classes that support $ref addressing
// -------------------------------------------------------------
public string GetCollectionWithReferencesClassDefinition(OdcmProperty odcmProperty)
{
    return this.GetClassDefinition(this.GetPropertyCollectionWithReferencesRequestName(odcmProperty));
}

public string GetCollectionWithReferencesRequestConstructor(OdcmProperty odcmProperty)
{
    return this.GetConstructor(this.GetPropertyCollectionWithReferencesRequestName(odcmProperty));
}


// -------------------------------------------------------------
// Build CRUD methods
// -------------------------------------------------------------

public void AppendMethodHeaderToPostAsyncMethod(string propertyType, string sanitizedPropertyName, StringBuilder stringBuilder, bool includeSendParameters)
{
    stringBuilder.Append("        /// <summary>");
    stringBuilder.Append(Environment.NewLine);
    stringBuilder.AppendFormat("        /// Adds the specified {0} to the collection via POST.", propertyType);
    stringBuilder.Append(Environment.NewLine);
    stringBuilder.Append("        /// </summary>");
    stringBuilder.Append(Environment.NewLine);
    stringBuilder.AppendFormat("        /// <param name=\"{0}\">The {1} to add.</param>", sanitizedPropertyName, propertyType);

    if (includeSendParameters)
    {
        stringBuilder.Append(Environment.NewLine);
        stringBuilder.Append("        /// <param name=\"cancellationToken\">The <see cref=\"CancellationToken\"/> for the request.</param>");
    }
}

public string GetPostAsyncMethod(OdcmProperty odcmProperty, string requestBody = null)
{
    if (!odcmProperty.LongDescriptionContains("readonly"))
    {
        var sanitizedPropertyName = odcmProperty.Projection.Type.Name.GetSanitizedPropertyName(odcmProperty.Name);
        var propertyType = this.GetPropertyTypeName(odcmProperty);

		if (propertyType.EndsWith("Request"))
		{
			propertyType = String.Concat(propertyType, "Object");
		}

        var templateWriterHost = (CustomT4Host)Host;
        var templateWriter = (CodeWriterCSharp)templateWriterHost.CodeWriter;

        var stringBuilder = new StringBuilder();

        stringBuilder.Append(Environment.NewLine);
        this.AppendMethodHeaderToPostAsyncMethod(propertyType, sanitizedPropertyName, stringBuilder, false);
        stringBuilder.Append(Environment.NewLine);
        stringBuilder.AppendFormat("        /// <returns>The created {0}.</returns>", propertyType);
        stringBuilder.Append(Environment.NewLine);
        stringBuilder.AppendFormat("        public System.Threading.Tasks.Task<{0}> AddAsync({0} {1})", propertyType, sanitizedPropertyName);
        stringBuilder.Append(Environment.NewLine);
        stringBuilder.Append("        {");
        stringBuilder.Append(Environment.NewLine);
        stringBuilder.AppendFormat("            return this.AddAsync({0}, CancellationToken.None);", sanitizedPropertyName);
        stringBuilder.Append(Environment.NewLine);
        stringBuilder.Append("        }");

        stringBuilder.Append(Environment.NewLine);
        stringBuilder.Append(Environment.NewLine);

        this.AppendMethodHeaderToPostAsyncMethod(propertyType, sanitizedPropertyName, stringBuilder, true);
        stringBuilder.Append(Environment.NewLine);
        stringBuilder.AppendFormat("        /// <returns>The created {0}.</returns>", propertyType);
        stringBuilder.Append(Environment.NewLine);
        stringBuilder.AppendFormat("        public System.Threading.Tasks.Task<{0}> AddAsync({0} {1}, CancellationToken cancellationToken)", propertyType, sanitizedPropertyName);
        stringBuilder.Append(Environment.NewLine);
        stringBuilder.Append("        {");
        stringBuilder.Append(Environment.NewLine);
        stringBuilder.AppendFormat("            this.ContentType = \"{0}\";", templateWriter.jsonContentType);
        stringBuilder.Append(Environment.NewLine);
        stringBuilder.Append("            this.Method = \"POST\";");

        var entity = odcmProperty.Projection.Type.AsOdcmClass();

        if (entity != null && entity.IsAbstract)
        {
            stringBuilder.Append(Environment.NewLine);
            stringBuilder.AppendFormat("            {0}.ODataType = string.Concat(\"#\", StringHelper.ConvertTypeToLowerCamelCase({0}.GetType().FullName));", sanitizedPropertyName);
        }

        stringBuilder.Append(Environment.NewLine);
        stringBuilder.AppendFormat("            return this.SendAsync<{0}>({1}, cancellationToken);", propertyType, sanitizedPropertyName);
        stringBuilder.Append(Environment.NewLine);
        stringBuilder.Append("        }");
        stringBuilder.Append(Environment.NewLine);

        return stringBuilder.ToString();
    }

    return string.Empty;
}

public string GetImplicitNavigationPropertyUrlSegment(OdcmSingleton singleton, OdcmProperty odcmProperty)
{
		/****
		To help the future dev in figuring this out, put a break point on the next executable line
		with the condition odcmProperty.Name == "teachers". The CSDL in and entities mentioned in these 
		comments are an example of the use of this scenario. 
		
		****/


        // (1) Check that there are NavigationPropertyBindings. If there aren't any, then we know this segment of 
		// the canonical path to the reference.
        if (singleton.NavigationPropertyBindings.Count == 0)
        {
			return "/" + odcmProperty.Name;
        }

        // (2) Get all of the keys that contain our target path name. The keys come from the Path attribute on a 
		// NavigationPropertyBinding. So if our target property (OdcmProperty.Name) is named 'teachers', then we need to only consider
		// NavigationPropertyBinding paths that end with 'teachers'. The NavigationPropertyBindings are found in the Singleton that 
		// defines the EntitySet that contains this property. The NavigationPropertyBindings provide generation hints for how to 
		// reference non-contained entities that are defined within the same Singleton (this statement is conjecture). This generation
		// hints is used to specify a reference URL for $ref call. 

		// Example: in this case, "teachers". This should be the end part of the BindingPath.

        IEnumerable<string> keys = singleton.NavigationPropertyBindings.Where(kvp => kvp.Key.EndsWith(odcmProperty.Name)).Select(kvp => kvp.Key);
		/*
                <Singleton Name="education" Type="microsoft.graph.educationRoot">
                     <NavigationPropertyBinding Path="classes/teachers" Target="users" />
                    <NavigationPropertyBinding Path="classes/members" Target="users" />
                    <NavigationPropertyBinding Path="classes/schools" Target="schools" />
                    <NavigationPropertyBinding Path="schools/classes" Target="classes" />
                    <NavigationPropertyBinding Path="schools/users" Target="users" />
                    <NavigationPropertyBinding Path="users/schools" Target="schools" />
                    <NavigationPropertyBinding Path="users/classes" Target="classes" />
                </Singleton>

				<EntityType Name="educationRoot" BaseType="microsoft.graph.entity">
					<NavigationProperty Name="synchronizationProfiles" Type="Collection(microsoft.graph.educationSynchronizationProfile)" ContainsTarget="true" />
					 <NavigationProperty Name="classes" Type="Collection(microsoft.graph.educationClass)" ContainsTarget="true" />
					<NavigationProperty Name="schools" Type="Collection(microsoft.graph.educationSchool)" ContainsTarget="true" />
					<NavigationProperty Name="users" Type="Collection(microsoft.graph.educationUser)" ContainsTarget="true" />
					<NavigationProperty Name="me" Type="microsoft.graph.educationUser" ContainsTarget="true" />
				</EntityType>

				<EntityType Name="educationClass" BaseType="microsoft.graph.entity">
					<Property Name="displayName" Type="Edm.String" Nullable="false" />
					<NavigationProperty Name="schools" Type="Collection(microsoft.graph.educationSchool)" />
					<NavigationProperty Name="members" Type="Collection(microsoft.graph.educationUser)" />
 					 <NavigationProperty Name="teachers" Type="Collection(microsoft.graph.educationUser)" />
					<NavigationProperty Name="group" Type="microsoft.graph.group" />
					<NavigationProperty Name="assignments" Type="Collection(microsoft.graph.educationAssignment)" ContainsTarget="true" />
				</EntityType>
		*/

		// We need to support long NavPropBindings. That is, we need to support multi-segment NavigationPropertyBinding paths
		// (3) We need to query the paths in {keys} against the entity (odcmProperty.Class) that contains this navigation property (odcmProperty). 
		//	   We need to determine the unique binding path from the singleton through the entity on to this navigation property, query the keys
		//       for it, and then get the target. There could be 1 or more pat segments that we need to account for.
		// Example: odcmProperty.Class is the entity "educationClass" that has the non-contained navigation property represented by odcmProperty,
		// which is named 'teachers'. At this point, we know the singleton and all of its NavigationPropertyBindings, we know the singleton's entity type,
		// which is named 'educationRoot'.
		// We need to determine whether a NavigationPropertyBinding pth and target is different than the CSDL described path to the reference non-contained entity. 

		// odcmProperty.Name; // --> "teachers"

		var navPropClassToFind = odcmProperty.Class.Name; // -- > "educationClass"; This is the EntityType that contains the navigation property
		string firstBindingPathSegment = ""; // We are incorrectly assuming to segment.
				
		// Get the path segments.
		//string[] navPropBindingSegments = keys.First().Split('/'); 

		// Example: After hitting the conditional breakpoint, singleton.Type.Name is "educationRoot". 
		// We are going to inspect each navigation property on singleton's type and compare to the segments
		// in the keys IEnumerable. 
		// The assumption here is that the first segment is a navigation property of the singleton's type
		// The second assumption is that there are only two segments. We know this is a bad assumption.
		// The third assumption is that the last segment is the most meaningful. 
		// In short, this only works for a Path that has two segments.

		foreach (OdcmProperty prop in (singleton.Type as OdcmEntityClass).Properties)
		{
			if (prop.Type.Name == navPropClassToFind)
			{
				firstBindingPathSegment = prop.Name;
				break;
			}		 	
		}

		/*
			What we know.

			We know the navigation property name and type.
			We know whih entity contains the navigation property.
			We know that the navigation property does not contain the entity.
			We know which singleton is the entity set for the navigation property.
			We know the singleton's type.
			We know the NavigationPropertyBindings and which candidates CAN be the one to define the reference path to the entity in the navigation.

			We don't know the paths to the entity that contains our navigation property. So, the question is, can we know the context in which the 
			navigation property is being accessed at generation time? I don't think we can.

			The next question is can we code the templates to generate code that is context aware and can create the ref path based on that context. 
			This is a maybe. 

			Our current example works since the scenario only has two levels of entities. What happens when we have three level of entities like
			/schools/classes/teachers. We know the teachers segments. We don't have context which entities are accessed across the request builders
			at runtime. 

			We may need to generate a dictionary from the NavPropBindings in to the code files and use those at runtime to discover the context in
			which a navigtion is called in order to provide the correct reference path. 

			TODO: investigate what it would take to generate code that is context aware of binding path.
		*/

		string secondBindingPathSegment = odcmProperty.Name;

		//string bindingPath = firstBindingPathSegment + "/" + keys.First(); // TODO: Need to fix this.
		string bindingPath = firstBindingPathSegment + "/" + secondBindingPathSegment;

		string bindingTarget;

		if (singleton.NavigationPropertyBindings.TryGetValue(bindingPath, out bindingTarget))
		{
			// We found the target
			return "/" + bindingTarget;
		}
		else
			 return "/" + odcmProperty.Name;
}

public string GetPostAsyncMethodForReferencesRequest(OdcmProperty odcmProperty)
{
    var sanitizedPropertyName = odcmProperty.Projection.Type.Name.GetSanitizedPropertyName(odcmProperty.Name);
    var propertyType = this.GetPropertyTypeName(odcmProperty);

    var templateWriterHost = (CustomT4Host)Host;
    var templateWriter = (CodeWriterCSharp)templateWriterHost.CodeWriter;

    var serviceNavigationProperty = odcmProperty.GetServiceCollectionNavigationPropertyForPropertyType();
	if (serviceNavigationProperty == null)
		return string.Empty;
	
	var implicitNavigationProperty = string.Empty;
	
	// If the odcmProperty is a part of Singleton, then we need to determine whether there is a  
	// NavigationPropertyBinding generation hint. If there is, then we need to use it for 
	// creating the URL of a reference entity in a POST body. 
	if (serviceNavigationProperty.GetType() == typeof(OdcmSingleton)) 
	{
		var singleton = (OdcmSingleton)serviceNavigationProperty;

        implicitNavigationProperty = GetImplicitNavigationPropertyUrlSegment(singleton, odcmProperty);
	}

    var stringBuilder = new StringBuilder();

    stringBuilder.Append(Environment.NewLine);
    this.AppendMethodHeaderToPostAsyncMethod(propertyType, sanitizedPropertyName, stringBuilder, false);
    stringBuilder.Append(Environment.NewLine);
    stringBuilder.AppendFormat("        /// <returns>The task to await.</returns>", propertyType);
    stringBuilder.Append(Environment.NewLine);
    stringBuilder.AppendFormat("        public System.Threading.Tasks.Task AddAsync({0} {1})", propertyType, sanitizedPropertyName);
    stringBuilder.Append(Environment.NewLine);
    stringBuilder.Append("        {");
    stringBuilder.Append(Environment.NewLine);
    stringBuilder.AppendFormat("            return this.AddAsync({0}, CancellationToken.None);", sanitizedPropertyName);
    stringBuilder.Append(Environment.NewLine);
    stringBuilder.Append("        }");

    stringBuilder.Append(Environment.NewLine);
    stringBuilder.Append(Environment.NewLine);

    this.AppendMethodHeaderToPostAsyncMethod(propertyType, sanitizedPropertyName, stringBuilder, true);
    stringBuilder.Append(Environment.NewLine);
    stringBuilder.AppendFormat("        /// <returns>The task to await.</returns>", propertyType);
    stringBuilder.Append(Environment.NewLine);
    stringBuilder.AppendFormat("        public System.Threading.Tasks.Task AddAsync({0} {1}, CancellationToken cancellationToken)", propertyType, sanitizedPropertyName);
    stringBuilder.Append(Environment.NewLine);
    stringBuilder.Append("        {");
    stringBuilder.Append(Environment.NewLine);
    stringBuilder.AppendFormat("            this.ContentType = \"{0}\";", templateWriter.jsonContentType);
    stringBuilder.Append(Environment.NewLine);
    stringBuilder.Append("            this.Method = \"POST\";");
    stringBuilder.Append(Environment.NewLine);
    stringBuilder.Append(Environment.NewLine);
    stringBuilder.AppendFormat("            if (string.IsNullOrEmpty({0}.Id))", sanitizedPropertyName);
    stringBuilder.Append(Environment.NewLine);
    stringBuilder.Append("            {");
    stringBuilder.Append(Environment.NewLine);
    stringBuilder.Append("                throw new ServiceException(new Error { Code = \"invalidRequest\", Message = \"ID is required to add a reference.\" });");
    stringBuilder.Append(Environment.NewLine);
    stringBuilder.Append("            }");
    stringBuilder.Append(Environment.NewLine);
    stringBuilder.Append(Environment.NewLine);
    stringBuilder.AppendFormat("            var requestBody = new ReferenceRequestBody {{ ODataId = string.Format(\"{{0}}/{0}{1}/{{1}}\", this.Client.BaseUrl, {2}.Id) }};", serviceNavigationProperty.Name, implicitNavigationProperty, sanitizedPropertyName);
    stringBuilder.Append(Environment.NewLine);
    stringBuilder.AppendFormat("            return this.SendAsync(requestBody, cancellationToken);");
    stringBuilder.Append(Environment.NewLine);
    stringBuilder.Append("        }");
    stringBuilder.Append(Environment.NewLine);

    return stringBuilder.ToString();
}

#>
